1. Qual a diferença entre tipagem dinâmica e tipagem estática? 

A tipagem dinâmica ocorre quando o tipo da variável é definido e verificado somente em tempo de execução, permitindo que uma mesma variável assuma valores de diferentes tipos ao longo do programa. A vantagem da tipagem dinâmica é a maior flexibilidade facilitada na escrita do código e seu maior defeito é a maior quantidade de erros de operações inválidas ou de tipagem.
Tipagem estática é caracterizado quando definimos o tipo da variável no momento em que declaramos ex: em C “int idade = 18;”. A variável idade é do tipo inteiro e não pode ser alterada para outro tipo como transformar ele num string. tipagem estática permite a detecção de erros de tipo mais cedo no ciclo de desenvolvimento, aumentando a segurança e confiabilidade do código, entretanto exige um rigor maior por parte do programador, já que desde o início declaramos o tipo da variável.

2. Qual o principal problema do uso de tipagem dinâmica? 

O principal problema é o erro de tipo e ele só é identificado durante a execução do código.

3. Pesquise um exemplo na internet em que a tipagem dinâmica pode ser problemática.

Um exemplo em que a tipagem dinâmica pode ser problemática acontece em linguagens como JavaScript. Imagine uma variável inicialmente declarada como número, recebendo o valor 25. Em seguida, essa mesma variável é atribuída a uma string, como “vinte cinco”. Quando o programa tenta multiplicar essa variável por 2, o resultado não é o esperado, pois a operação entre string e número não faz sentido, retornando o valor especial NaN (“Not a Number”). Esse tipo de situação é perigoso porque o erro só é identificado em tempo de execução, podendo causar falhas inesperadas e difíceis de rastrear, já que em programas maiores pode ser complicado descobrir em qual ponto a variável deixou de ser numérica.

4. Crie uma variável chamada idade do tipo number e tente atribuir a ela um valor string. O que acontece?

Type 'string' is not assignable to type 'number'. O compilador não permite que eu atribua um valor do tipo ‘string’ a um do tipo ‘number’

5. Agora crie a variável nome sem declarar o tipo (apenas let nome = "Ely";). Qual o tipo inferido pelo TypeScript?

let nome = "Ely";
console.log(typeof nome);

automaticamente ela assume que nome é do tipo ‘string’ mas podemos também especificar antes que é uma ‘string’ que daria no mesmo.

6. Pesquise e exemplifique porque dizemos que a linguagem C, mesmo tendo tipagem estática, possui tipagem fraca.

A linguagem C é estaticamente tipada porque os tipos das variáveis são definidos em tempo de compilação, mas é fracamente tipada porque permite conversões automáticas (implícitas) entre tipos de dados incompatíveis sem gerar erro. Essa conversão automática, embora flexível, pode resultar em resultados imprevisíveis e é a razão pela qual, apesar da tipagem estática, ela é considerada fracamente tipada.

float a;  // Variável de ponto flutuante
int b = 1;
int c = 2;

a = b / c; // O compilador não gera erro, mas realiza uma conversão implícita

7. Poderíamos dizer que a tipagem do TypeScript é fraca por uma variável do tipo number aceitar tanto inteiros como ponto flutuante?

Não, o fato de o tipo number no TypeScript aceitar inteiros e números de ponto flutuante não indica tipagem fraca. TypeScript é estaticamente tipado e mantém a consistência dos tipos; tipagem fraca ocorreria quando há mistura de tipos sem verificação de consistência.

Quais os resultados? Teça comentários a respeito

8. Execute os exemplos abaixo em um ambiente de JavaScript puro: 
a. Exemplo 1: O resultado foi “105” isso porque ele concatena a variável tipo number “a” que 10 com a string 5 e ficou 10 + “5” que devolveu 105.
b. Exemplo 2: O resultado é 3 porque ela soma x = true que considera 1 e soma com y = 2. transformando em 3.
c. Exemplo 3: ele considera 0 = falso então devolve “true”, uma “string” vazia(“”) é considerada falsa e então novamente ele devolve true.

9. Execute os dois mesmos exemplos em um ambiente TypeScript. Verifique o que acontece e comente sobre.

Ambos deu erro de compilação
